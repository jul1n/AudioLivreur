import os
import shutil
import tempfile
import subprocess
import re
import asyncio
import ebooklib
from ebooklib import epub
from bs4 import BeautifulSoup

class Converter:
    def __init__(self, epub_path, ffmpeg_path, voice, rate, volume, keep_mp3s=False, 
                 progress_callback=None, log_callback=None, finished_callback=None, text_callback=None):
        self.epub_path = epub_path
        self.ffmpeg_path = ffmpeg_path
        self.voice = voice
        self.rate = rate
        self.volume = volume
        self.keep_mp3s = keep_mp3s
        self.cancel_requested = False
        self.temp_dir = None
        
        self.progress_callback = progress_callback
        self.log_callback = log_callback
        self.finished_callback = finished_callback
        self.text_callback = text_callback

    def emit_text(self, text):
        if self.text_callback:
            self.text_callback(text)

    def scan_file(self):
        try:
            chapters = self.extract_text(self.epub_path)
            word_count = sum(len(text.split()) for _, text in chapters)
            return len(chapters), word_count
        except Exception as e:
            return 0, 0

    def emit_progress(self, current, total, msg):
        if self.progress_callback:
            self.progress_callback(current, total, msg)

    def emit_log(self, msg):
        if self.log_callback:
            self.log_callback(msg)

    def emit_finished(self, success, msg):
        if self.finished_callback:
            self.finished_callback(success, msg)

    def run(self):
        try:
            self.do_work()
        except Exception as e:
            import traceback
            import traceback
            self.emit_log(traceback.format_exc())
            self.emit_finished(False, str(e))
        self.temp_dir = tempfile.mkdtemp(prefix="calibaudio_")
        self.emit_log(f"Temp directory: {self.temp_dir}")

        mp3_files = []
        total_steps = len(chapters) + 1

        # 3. Generate Audio
        import edge_tts
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        for i, (title, text) in enumerate(chapters):
            if self.cancel_requested:
                self.cleanup()
                self.emit_finished(False, "Cancelled by user.")
                return

            safe_title = "".join([c for c in title if c.isalnum() or c in (' ', '-', '_')]).strip()
            if not safe_title:
                safe_title = f"Chapter_{i+1}"
            
            filename = f"{i+1:03d}_{safe_title}.mp3"
            filepath = os.path.join(self.temp_dir, filename)
            
            self.emit_progress(i, total_steps, f"TTS ({i+1}/{len(chapters)}): {title}")
            self.emit_log(f"[{i+1}/{len(chapters)}] Generating audio: {title}...")
            
            # Emit word progress instead of text preview
            words_in_chapter = len(text.split())
            total_words_so_far = sum(len(chapters[j][1].split()) for j in range(i))
            total_words = sum(len(ch[1].split()) for ch in chapters)
            progress_msg = f"{total_words_so_far + words_in_chapter}/{total_words} mots"
            self.emit_text(progress_msg)

            try:
                loop.run_until_complete(self.generate_tts(text, filepath))
            except Exception as e:
                self.emit_log(f"Error generating chapter: {e}")
                raise e
            
            mp3_files.append((title, filepath))

        loop.close()

        # 4. Merge
        if self.cancel_requested:
            self.cleanup()
            self.emit_finished(False, "Cancelled by user.")
            return

        self.emit_progress(total_steps - 1, total_steps, "Merging to M4B...")
        self.emit_log("Merging with FFmpeg...")
        
        output_dir = os.path.dirname(self.epub_path)
        base_name = os.path.splitext(os.path.basename(self.epub_path))[0]
        output_m4b = os.path.join(output_dir, f"{base_name}.m4b")
        
        self.merge_audio(mp3_files, output_m4b)
        self.emit_log(f"Created M4B: {output_m4b}")

        # 5. Cleanup
        if self.keep_mp3s:
            mp3_export_dir = os.path.join(output_dir, f"{base_name}_MP3s")
            if not os.path.exists(mp3_export_dir):
                os.makedirs(mp3_export_dir)
            for _, mp3_path in mp3_files:
                shutil.copy(mp3_path, mp3_export_dir)
            self.emit_log(f"MP3s saved to: {mp3_export_dir}")

            for _, mp3_path in mp3_files:
                shutil.copy(mp3_path, mp3_export_dir)
            self.emit_log(f"MP3s saved to: {mp3_export_dir}")

        # Note: We do NOT cleanup here automatically anymore to allow "Export MP3" button to work
        # The UI must call cleanup() when done or on exit.
        self.emit_finished(True, "Conversion completed successfully!")

    def cleanup(self):
        if self.temp_dir and os.path.exists(self.temp_dir):
            try:
                shutil.rmtree(self.temp_dir, ignore_errors=True)
                self.emit_log(f"Cleaned up temp dir: {self.temp_dir}")
            except Exception as e:
                self.emit_log(f"Error cleaning up: {e}")
        self.temp_dir = None

    def extract_text(self, file_path):
        ext = os.path.splitext(file_path)[1].lower()
        
        if ext == '.epub':
            return self.extract_epub(file_path)
        elif ext == '.pdf':
            return self.extract_pdf(file_path)
        elif ext == '.docx':
            return self.extract_docx(file_path)
        elif ext in ['.txt', '.md']:
            return self.extract_text_file(file_path)
        elif ext in ['.mobi', '.azw3']:
            return self.extract_mobi(file_path)
        else:
            raise Exception(f"Unsupported file format: {ext}")

    def extract_epub(self, epub_path):
        book = epub.read_epub(epub_path)
        chapters = []
        for item_id in book.spine:
            item = book.get_item_with_id(item_id[0])
            if not item: continue
            if item.get_type() == ebooklib.ITEM_DOCUMENT:
                soup = BeautifulSoup(item.get_content(), 'html.parser')
                for tag in soup(['script', 'style', 'img', 'svg']): tag.decompose()
                text = soup.get_text(separator=' ', strip=True)
                if len(text) < 100: continue
                
                title = f"Chapter {len(chapters)+1}"
                h1 = soup.find('h1')
                if h1: title = h1.get_text(strip=True)
                elif soup.find('h2'): title = soup.find('h2').get_text(strip=True)
                
                chapters.append((title, text))
        return chapters

    def extract_pdf(self, pdf_path):
        import pypdf
        self.emit_log("[DEBUG] Starting PDF extraction...")
        chapters = []
        try:
            self.emit_log(f"[DEBUG] Opening PDF: {pdf_path}")
            reader = pypdf.PdfReader(pdf_path)
            self.emit_log(f"[DEBUG] PDF has {len(reader.pages)} pages")
            
            full_text = ""
            for i, page in enumerate(reader.pages):
                self.emit_log(f"[DEBUG] Extracting page {i+1}/{len(reader.pages)}...")
                page_text = page.extract_text()
                full_text += page_text + "\n\n"
                self.emit_log(f"[DEBUG] Page {i+1} extracted: {len(page_text)} characters")
            
            self.emit_log(f"[DEBUG] Total text extracted: {len(full_text)} characters")
            self.emit_log(f"[DEBUG] Total words: {len(full_text.split())}")
            
            if not full_text.strip():
                self.emit_log("[ERROR] PDF text extraction resulted in empty text!")
                raise Exception("No text could be extracted from PDF. The PDF might be image-based.")
            
            chapters.append(("Full Document", full_text))
            self.emit_log(f"[DEBUG] PDF extraction successful: 1 chapter created")
        except Exception as e:
            self.emit_log(f"[ERROR] PDF extraction failed: {str(e)}")
            raise Exception(f"Error reading PDF: {e}")
        return chapters

    def extract_docx(self, docx_path):
        import docx
        chapters = []
        try:
            doc = docx.Document(docx_path)
            full_text = "\n".join([p.text for p in doc.paragraphs])
            chapters.append(("Full Document", full_text))
        except Exception as e:
            raise Exception(f"Error reading DOCX: {e}")
        return chapters

    def extract_text_file(self, txt_path):
        chapters = []
        try:
            with open(txt_path, 'r', encoding='utf-8', errors='ignore') as f:
                full_text = f.read()
            chapters.append(("Full Document", full_text))
        except Exception as e:
            raise Exception(f"Error reading Text file: {e}")
        return chapters

    def extract_mobi(self, mobi_path):
        import mobi
        chapters = []
        try:
            temp_dir = tempfile.mkdtemp()
            temp_html = os.path.join(temp_dir, "book.html")
            mobi.extract(mobi_path, temp_html)
            
            if os.path.exists(temp_html):
                with open(temp_html, 'r', encoding='utf-8', errors='ignore') as f:
                    soup = BeautifulSoup(f.read(), 'html.parser')
                    for tag in soup(['script', 'style', 'img', 'svg']): tag.decompose()
                    text = soup.get_text(separator=' ', strip=True)
                    chapters.append(("Full Document", text))
            shutil.rmtree(temp_dir, ignore_errors=True)
        except Exception as e:
             raise Exception(f"Error reading MOBI/AZW3: {e}")
        return chapters

    async def generate_tts(self, text, output_file):
        import edge_tts
        communicate = edge_tts.Communicate(text, self.voice, rate=self.rate, volume=self.volume)
        await communicate.save(output_file)

    def merge_audio(self, mp3_files, output_file):
        list_file_path = os.path.join(os.path.dirname(mp3_files[0][1]), 'files.txt')
        with open(list_file_path, 'w', encoding='utf-8') as f:
            for _, path in mp3_files:
                safe_path = path.replace('\\', '/').replace("'", "'\\''")
                f.write(f"file '{safe_path}'\n")

        metadata_file_path = os.path.join(os.path.dirname(mp3_files[0][1]), 'metadata.txt')
        self.create_ffmpeg_metadata(mp3_files, metadata_file_path)

        cmd = [
            self.ffmpeg_path,
            '-f', 'concat',
            '-safe', '0',
            '-i', list_file_path,
            '-i', metadata_file_path,
            '-map_metadata', '1',
            '-c:a', 'aac',
            '-b:a', '64k',
            '-vn',
            '-y',
            output_file
        ]
        
        if os.name == 'nt':
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        else:
            startupinfo = None

        process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, startupinfo=startupinfo)
        _, stderr = process.communicate()
        
        if process.returncode != 0:
            raise Exception(f"FFmpeg Error: {stderr.decode('utf-8', errors='ignore')}")

    def create_ffmpeg_metadata(self, mp3_files, output_path):
        chapters_info = []
        current_start = 0
        
        for title, path in mp3_files:
            duration = self.get_duration(path)
            end = current_start + duration
            chapters_info.append((title, int(current_start * 1000), int(end * 1000))) 
            current_start = end
            
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(";FFMETADATA1\n")
            for title, start, end in chapters_info:
                f.write("[CHAPTER]\n")
                f.write("TIMEBASE=1/1000\n")
                f.write(f"START={start}\n")
                f.write(f"END={end}\n")
                f.write(f"title={title}\n")

    def get_duration(self, file_path):
        cmd = [self.ffmpeg_path, '-i', file_path]
        if os.name == 'nt':
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
        else:
            startupinfo = None
            
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, startupinfo=startupinfo)
        _, stderr = p.communicate()
        
        out = stderr.decode('utf-8', errors='ignore')
        match = re.search(r'Duration: (\d+):(\d+):(\d+\.\d+)', out)
        if match:
            h, m, s = match.groups()
            return int(h) * 3600 + int(m) * 60 + float(s)
        return 0
